<!DOCTYPE html><html><head><title>Laravel队列的一个问题</title><meta charset='utf-8'><link href='https://dn-maxiang.qbox.me/res-min/themes/marxico.css' rel='stylesheet'><style>
.note-content  {font-family: 'Helvetica Neue', Arial, 'Hiragino Sans GB', STHeiti, 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, Song, sans-serif;}

</style></head><body><div id='preview-contents' class='note-content'>
                        <div id="wmd-preview" class="preview-content"></div>
                    <div id="wmd-preview-section-1171" class="wmd-preview-section preview-content">

<p></p>

</div><div id="wmd-preview-section-1212" class="wmd-preview-section preview-content">

<h2 id="laravel队列的一个问题">Laravel队列的一个问题</h2>

<blockquote>
  <p>众所周知Laravel队列的启动有两个命令，分别是<code>queue:listen</code>和<code>queue:work</code>命令。后者有一个<code>--daemon</code>参数效率是很高的。为什么呢?官方解释说:<strong>不会每次重新启动框架，但是增加了部署时，对于处理中队列任务的的复杂性</strong>。我很想问一句、<strong>这是为什么?</strong></p>
</blockquote>

<p>其实原因在于<code>queue:listen</code>只是每隔3秒循环执行下<code>php artisan queue:work</code>命令启动子进程，该命令会导致框架的启动,然后会去处理队列中的一个任务(如果有的话)，最后自己死掉，就这样周而复始,所以说<code>listen</code>每次都会启动框架!!!<code>queue:work --daemon</code>处理一个任务则是在同进程内通过容器执行，所以不需要每次都启动框架！！！</p>

<p>来看源码，先从简单的<code>listen</code>入手: <br>
打开文件<code>vendor/laravel/framework/src/Illuminate/Queue/Listener.php</code></p></div><div id="wmd-preview-section-2" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs xquery"><span class="hljs-comment line-number">1.</span> /*<br><span class="hljs-comment line-number">2.</span>  *进程死循不断启动子进程<br><span class="hljs-comment line-number">3.</span>  */<br><span class="hljs-comment line-number">4.</span> public <span class="hljs-keyword">function</span> listen(<span class="hljs-variable">$connection</span>, <span class="hljs-variable">$queue</span>, <span class="hljs-variable">$delay</span>, <span class="hljs-variable">$memory</span>, <span class="hljs-variable">$timeout</span> = <span class="hljs-number">60</span>)<br><span class="hljs-comment line-number">5.</span>    {<br><span class="hljs-comment line-number">6.</span>      //创建一个进程对象,启动命令是:<span class="hljs-string">"C:\xampp\php\php.exe"</span> artisan queue:work  --queue=<span class="hljs-string">"default"</span> --delay=<span class="hljs-number">0</span> --memory=<span class="hljs-number">128</span> --sleep=<span class="hljs-number">3</span> --tries=<span class="hljs-number">0</span> --env=local<br><span class="hljs-comment line-number">7.</span>        <span class="hljs-variable">$process</span> = <span class="hljs-variable">$this-</span>&gt;makeProcess(<span class="hljs-variable">$connection</span>, <span class="hljs-variable">$queue</span>, <span class="hljs-variable">$delay</span>, <span class="hljs-variable">$memory</span>, <span class="hljs-variable">$timeout</span>);<br><span class="hljs-comment line-number">8.</span><br><span class="hljs-comment line-number">9.</span>        while (true) {<br><span class="hljs-comment line-number">10.</span>            //循环启动进程，为什么没有等待的三秒?其实<span class="hljs-number">3</span>秒的等待是在子进程来做的。因为两者是同步的，所以可以这么做。<br><span class="hljs-comment line-number">11.</span>            <span class="hljs-variable">$this-</span>&gt;runProcess(<span class="hljs-variable">$process</span>, <span class="hljs-variable">$memory</span>);<br><span class="hljs-comment line-number">12.</span>        }<br><span class="hljs-comment line-number">13.</span>    }<br><span class="hljs-comment line-number">14.</span>//运行进程<br><span class="hljs-comment line-number">15.</span>public <span class="hljs-keyword">function</span> runProcess(Process <span class="hljs-variable">$process</span>, <span class="hljs-variable">$memory</span>)<br><span class="hljs-comment line-number">16.</span>    {<br><span class="hljs-comment line-number">17.</span>        <span class="hljs-variable">$process-</span>&gt;run(function (<span class="hljs-variable">$type</span>, <span class="hljs-variable">$line</span>) {<br><span class="hljs-comment line-number">18.</span>            <span class="hljs-variable">$this-</span>&gt;handleWorkerOutput(<span class="hljs-variable">$type</span>, <span class="hljs-variable">$line</span>);<br><span class="hljs-comment line-number">19.</span>        });<br><span class="hljs-comment line-number">20.</span><br><span class="hljs-comment line-number">21.</span>        //主要想说这里，当内存使用超过限制，listen进程会杀死自己<br><span class="hljs-comment line-number">22.</span>        //work也是一样。所以在生产环境需要一个监控程序来保证<br><span class="hljs-comment line-number">23.</span>        队列监听程序一直活着<br><span class="hljs-comment line-number">24.</span>        if (<span class="hljs-variable">$this-</span>&gt;memoryExceeded(<span class="hljs-variable">$memory</span>)) {<br><span class="hljs-comment line-number">25.</span>            <span class="hljs-variable">$this-</span>&gt;stop();<br><span class="hljs-comment line-number">26.</span>        }<br><span class="hljs-comment line-number">27.</span>    }<br></code></pre>

<p>可以看到，<code>listen</code>命令根本不关心队列里面有没有任务，就启动进程。即使有任务，一旦新的进程启动起来，就会导致加载框架。不拉不拉一大堆的工作开始…..所以<code>listen</code>效率不高。</p>

<p>再来看看<code>work</code>,这部分比较复杂。因为涉及到任务的真正处理工作。 <br>
文件<code>vendor/laravel/framework/src/Illuminate/Queue/Worker.php</code></p>

</div><div id="wmd-preview-section-3" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs xquery"><span class="hljs-comment line-number">1.</span>/*<br><span class="hljs-comment line-number">2.</span> *死循环开始监听队列<br><span class="hljs-comment line-number">3.</span> */<br><span class="hljs-comment line-number">4.</span>public <span class="hljs-keyword">function</span> daemon(<span class="hljs-variable">$connectionName</span>, <span class="hljs-variable">$queue</span> = null, <span class="hljs-variable">$delay</span> = <span class="hljs-number">0</span>, <span class="hljs-variable">$memory</span> = <span class="hljs-number">128</span>, <span class="hljs-variable">$sleep</span> = <span class="hljs-number">3</span>, <span class="hljs-variable">$maxTries</span> = <span class="hljs-number">0</span>)<br><span class="hljs-comment line-number">5.</span>    {<br><span class="hljs-comment line-number">6.</span>        <span class="hljs-variable">$lastRestart</span> = <span class="hljs-variable">$this-</span>&gt;getTimestampOfLastQueueRestart();<br><span class="hljs-comment line-number">7.</span><br><span class="hljs-comment line-number">8.</span>        while (true) {<br><span class="hljs-comment line-number">9.</span>           //检测网站是否处于维护模式<br><span class="hljs-comment line-number">10.</span>            if (<span class="hljs-variable">$this-</span>&gt;daemonShouldRun()) {<br><span class="hljs-comment line-number">11.</span>              //不处理维护模式，拿取任务并执行。内部主要调用了pop函数<br><span class="hljs-comment line-number">12.</span>                <span class="hljs-variable">$this-</span>&gt;runNextJobForDaemon(<br><span class="hljs-comment line-number">13.</span>                    <span class="hljs-variable">$connectionName</span>, <span class="hljs-variable">$queue</span>, <span class="hljs-variable">$delay</span>, <span class="hljs-variable">$sleep</span>, <span class="hljs-variable">$maxTries</span><br><span class="hljs-comment line-number">14.</span>                );<br><span class="hljs-comment line-number">15.</span>            } else {<br><span class="hljs-comment line-number">16.</span>            //维护模式，休眠自己<br><span class="hljs-comment line-number">17.</span>                <span class="hljs-variable">$this-</span>&gt;sleep(<span class="hljs-variable">$sleep</span>);<br><span class="hljs-comment line-number">18.</span>            }<br><span class="hljs-comment line-number">19.</span>            //检测内存，是否应该杀死自己<br><span class="hljs-comment line-number">20.</span>            if (<span class="hljs-variable">$this-</span>&gt;memoryExceeded(<span class="hljs-variable">$memory</span>) || <span class="hljs-variable">$this-</span>&gt;queueShouldRestart(<span class="hljs-variable">$lastRestart</span>)) {<br><span class="hljs-comment line-number">21.</span>                <span class="hljs-variable">$this-</span>&gt;stop();<br><span class="hljs-comment line-number">22.</span>            }<br><span class="hljs-comment line-number">23.</span>        }<br><span class="hljs-comment line-number">24.</span>    }<br><span class="hljs-comment line-number">25.</span>//<br><span class="hljs-comment line-number">26.</span>  public <span class="hljs-keyword">function</span> pop(<span class="hljs-variable">$connectionName</span>, <span class="hljs-variable">$queue</span> = null, <span class="hljs-variable">$delay</span> = <span class="hljs-number">0</span>, <span class="hljs-variable">$sleep</span> = <span class="hljs-number">3</span>, <span class="hljs-variable">$maxTries</span> = <span class="hljs-number">0</span>)<br><span class="hljs-comment line-number">27.</span>    {<br><span class="hljs-comment line-number">28.</span>       //获取数据库驱动<br><span class="hljs-comment line-number">29.</span>        <span class="hljs-variable">$connection</span> = <span class="hljs-variable">$this-</span>&gt;manager-&gt;connection(<span class="hljs-variable">$connectionName</span>);<br><span class="hljs-comment line-number">30.</span>        //拿取第一个任务<br><span class="hljs-comment line-number">31.</span>        <span class="hljs-variable">$job</span> = <span class="hljs-variable">$this-</span>&gt;getNextJob(<span class="hljs-variable">$connection</span>, <span class="hljs-variable">$queue</span>);<br><span class="hljs-comment line-number">32.</span><br><span class="hljs-comment line-number">33.</span><br><span class="hljs-comment line-number">34.</span>        if (! is_null(<span class="hljs-variable">$job</span>)) {<br><span class="hljs-comment line-number">35.</span>            //处理任务，内部主要的是fire函数.<br><span class="hljs-comment line-number">36.</span>            return <span class="hljs-variable">$this-</span>&gt;process(<br><span class="hljs-comment line-number">37.</span>                <span class="hljs-variable">$this-</span>&gt;manager-&gt;getName(<span class="hljs-variable">$connectionName</span>), <span class="hljs-variable">$job</span>, <span class="hljs-variable">$maxTries</span>, <span class="hljs-variable">$delay</span><br><span class="hljs-comment line-number">38.</span>            );<br><span class="hljs-comment line-number">39.</span>        }<br><span class="hljs-comment line-number">40.</span>        //休息一会<br><span class="hljs-comment line-number">41.</span>        <span class="hljs-variable">$this-</span>&gt;sleep(<span class="hljs-variable">$sleep</span>);<br><span class="hljs-comment line-number">42.</span><br><span class="hljs-comment line-number">43.</span>        return [<span class="hljs-string">'job'</span> =&gt; null, <span class="hljs-string">'failed'</span> =&gt; false];<br><span class="hljs-comment line-number">44.</span>    }<br></code></pre>

<p>我们去找下<code>fire</code>函数的实现，打开<code>vendor/laravel/framework/src/Illuminate/Queue/Jobs</code>文件</p>

</div><div id="wmd-preview-section-4" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs xquery"><span class="hljs-comment line-number">1.</span> public <span class="hljs-keyword">function</span> fire()<br><span class="hljs-comment line-number">2.</span>    {<br><span class="hljs-comment line-number">3.</span>        <span class="hljs-variable">$this-</span>&gt;resolveAndFire(json_decode(<span class="hljs-variable">$this-</span>&gt;job-&gt;payload, true));<br><span class="hljs-comment line-number">4.</span>    }<br><span class="hljs-comment line-number">5.</span>    protected <span class="hljs-keyword">function</span> resolveAndFire(<span class="hljs-keyword">array</span> <span class="hljs-variable">$payload</span>)<br><span class="hljs-comment line-number">6.</span>    {<br><span class="hljs-comment line-number">7.</span>        //处理数据保存的任务信息，最后会调用Illuminate\Queue\CallQueuedHandler的call方法。<br><span class="hljs-comment line-number">8.</span>        list(<span class="hljs-variable">$class</span>, <span class="hljs-variable">$method</span>) = <span class="hljs-variable">$this-</span>&gt;parseJob(<span class="hljs-variable">$payload</span>[<span class="hljs-string">'job'</span>]);<br><span class="hljs-comment line-number">9.</span><br><span class="hljs-comment line-number">10.</span>        <span class="hljs-variable">$this-</span>&gt;instance = <span class="hljs-variable">$this-</span>&gt;resolve(<span class="hljs-variable">$class</span>);<br><span class="hljs-comment line-number">11.</span><br><span class="hljs-comment line-number">12.</span>        <span class="hljs-variable">$this-</span>&gt;instance-&gt;{<span class="hljs-variable">$method</span>}(<span class="hljs-variable">$this</span>, <span class="hljs-variable">$this-</span>&gt;resolveQueueableEntities(<span class="hljs-variable">$payload</span>[<span class="hljs-string">'data'</span>]));<br><span class="hljs-comment line-number">13.</span>    }<br></code></pre>

<p>贴下<code>jobs</code>表保存的数据格式，有助于理解</p>

</div><div id="wmd-preview-section-5" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs tex"><span class="hljs-comment line-number">1.</span><span class="hljs-special">{</span>"job":"Illuminate<span class="hljs-command">\\</span>Queue<span class="hljs-command">\\</span>CallQueuedHandler@call","data":<span class="hljs-special">{</span>"command":"O:21:<span class="hljs-command">\"</span>crm2<span class="hljs-command">\\</span>Jobs<span class="hljs-command">\\</span>ConvertFile<span class="hljs-command">\"</span>:4:<span class="hljs-special">{</span>s:7:<span class="hljs-command">\"</span><span class="hljs-command">\u</span>0000*<span class="hljs-command">\u</span>0000file<span class="hljs-command">\"</span>;O:45:<span class="hljs-command">\"</span>Illuminate<span class="hljs-command">\\</span>Contracts<span class="hljs-command">\\</span>Database<span class="hljs-command">\\</span>ModelIdentifier<span class="hljs-command">\"</span>:2:<span class="hljs-special">{</span>s:5:<span class="hljs-command">\"</span>class<span class="hljs-command">\"</span>;s:16:<span class="hljs-command">\"</span>crm2<span class="hljs-command">\\</span>Models<span class="hljs-command">\\</span>File<span class="hljs-command">\"</span>;s:2:<span class="hljs-command">\"</span>id<span class="hljs-command">\"</span>;i:22;<span class="hljs-special">}</span>s:5:<span class="hljs-command">\"</span>queue<span class="hljs-command">\"</span>;N;s:5:<span class="hljs-command">\"</span>delay<span class="hljs-command">\"</span>;N;s:6:<span class="hljs-command">\"</span><span class="hljs-command">\u</span>0000*<span class="hljs-command">\u</span>0000job<span class="hljs-command">\"</span>;N;<span class="hljs-special">}</span>"<span class="hljs-special">}</span><span class="hljs-special">}</span><br></code></pre>

<p>再去找<code>Illuminate\Queue\CallQueuedHandler</code>的<code>call</code>方法</p>

</div><div id="wmd-preview-section-6" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs xquery"><span class="hljs-comment line-number">1.</span> public <span class="hljs-keyword">function</span> call(Job <span class="hljs-variable">$job</span>, <span class="hljs-keyword">array</span> <span class="hljs-variable">$data</span>)<br><span class="hljs-comment line-number">2.</span>    {<br><span class="hljs-comment line-number">3.</span>        <span class="hljs-variable">$command</span> = <span class="hljs-variable">$this-</span>&gt;setJobInstanceIfNecessary(<br><span class="hljs-comment line-number">4.</span>            <span class="hljs-variable">$job</span>, unserialize(<span class="hljs-variable">$data</span>[<span class="hljs-string">'command'</span>])<br><span class="hljs-comment line-number">5.</span>        );<br><span class="hljs-comment line-number">6.</span>        //又飞了。。。。再去找吧<br><span class="hljs-comment line-number">7.</span>        <span class="hljs-variable">$this-</span>&gt;dispatcher-&gt;dispatchNow(<span class="hljs-variable">$command</span>);<br><span class="hljs-comment line-number">8.</span><br><span class="hljs-comment line-number">9.</span>        if (! <span class="hljs-variable">$job-</span>&gt;isDeletedOrReleased()) {<br><span class="hljs-comment line-number">10.</span>            <span class="hljs-variable">$job-</span>&gt;delete();<br><span class="hljs-comment line-number">11.</span>        }<br><span class="hljs-comment line-number">12.</span>    }<br></code></pre>

<p>打开<code>laravel/framework/src/Illuminate/Bus/Dispatcher.php</code>文件，找到<code>dispatchNow</code>函数。</p>

</div><div id="wmd-preview-section-1159" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs xquery"><span class="hljs-comment line-number">1.</span><span class="hljs-keyword">return</span> <span class="hljs-variable">$this-</span>&gt;pipeline-&gt;send(<span class="hljs-variable">$command</span>)-&gt;through(<span class="hljs-variable">$this-</span>&gt;pipes)-&gt;<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-variable">$command</span>) {<br><span class="hljs-comment line-number">2.</span>            return <span class="hljs-variable">$this-</span>&gt;container-&gt;call([<span class="hljs-variable">$command</span>, <span class="hljs-string">'handle'</span>]);<br><span class="hljs-comment line-number">3.</span>        });<br></code></pre>

<p>一目了然，使用的容器<code>call</code>方法。内部具体怎么处理的数据，怎么调用的我没看。以累残。。。</p>

<p>回过头看，为什么说增加了部署时候的复杂性。理由也很简单:框架只启动了一次，自定义的处理程序<code>类A</code>也就被<code>include</code>了一次，再次执任务的时候<code>类A</code>已经被加载进来、也就不会触发<code>spl_autoload_register</code>函数所定义的<code>loadClass</code>函数了。所以当更新源码<code>类A</code>的时候，是没有机会从新加载类的，所以需要手动启动启动下队列。而<code>listen</code>呢？刚好相反，不嫌累的三秒就干一次启动的活，干的很嗨皮呢！</p>

<p>至此文章结束。最后来总结下队列在队列中的目录组织结构</p></div><div id="wmd-preview-section-8" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs dart"><span class="hljs-comment line-number">1.</span>Illuminate/Queue<br><span class="hljs-comment line-number">2.</span>                        Capsule＝&gt;不知道<br><span class="hljs-comment line-number">3.</span>                        Connectors=&gt;数据连接<br><span class="hljs-comment line-number">4.</span>                        Console=&gt;对象相关的artisan命令<br><span class="hljs-comment line-number">5.</span>                        Events=&gt;不知道<br><span class="hljs-comment line-number">6.</span>                        Failed=&gt;失败任务处理，主要DatabaseFailedJobProvider问文件<br><span class="hljs-comment line-number">7.</span>                        Jobs=&gt;不同数据库中的Job记录，这个Job是jobs表里的一条记录，而不是我们定义的Job任务。<br><span class="hljs-comment line-number">8.</span>                       Worker.php=&gt;work命令实现<br><span class="hljs-comment line-number">9.</span>                       Listener.php=&gt;linsten命令实现<br><span class="hljs-comment line-number">10.</span>                       ....Queue.php＝&gt;各种队列的实现<br><span class="hljs-comment line-number">11.</span>                       CallQueueHandler.php=&gt;处理Job任务，我们之前分析过<br><span class="hljs-comment line-number">12.</span>                       ConsoleServiceProvider.php＝&gt;Queue服务提供者                    <br></code></pre>

</div><div id="wmd-preview-section-9" class="wmd-preview-section preview-content"></div><div id="wmd-preview-section-footnotes" class="preview-content"></div></div></body></html>