<!DOCTYPE html><html><head><title>Laravel5缓存源码阅读</title><meta charset='utf-8'><link href='https://dn-maxiang.qbox.me/res-min/themes/marxico.css' rel='stylesheet'><style>
.note-content  {font-family: 'Helvetica Neue', Arial, 'Hiragino Sans GB', STHeiti, 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, Song, sans-serif;}

</style></head><body><div id='preview-contents' class='note-content'>
                        <div id="wmd-preview" class="preview-content"></div>
                    <div id="wmd-preview-section-84" class="wmd-preview-section preview-content">

</div><div id="wmd-preview-section-311" class="wmd-preview-section preview-content">

<h2 id="laravel5缓存源码阅读">Laravel5缓存源码阅读</h2>

<p>今天遇到一个坑。从Laravel5.1升级到Laravel5.2之后。<code>Sessinon</code>会失效。查了半天原来是<code>app/Http/Kernel.php</code>的写法变了。增加了<code>middlewareGroups</code>这个变量。默认没有启用<code>Session</code>.  <br>
解决办法:在路由上增加web中间件的使用</p></div><div id="wmd-preview-section-10818" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs php"><span class="hljs-comment line-number">1.</span>Route::group([<br><span class="hljs-comment line-number">2.</span>    <span class="hljs-string">'middleware'</span> =&gt; [<br><span class="hljs-comment line-number">3.</span>        <span class="hljs-string">'web'</span><br><span class="hljs-comment line-number">4.</span>    ] <br><span class="hljs-comment line-number">5.</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{<br><span class="hljs-comment line-number">6.</span>   <span class="hljs-comment">//......</span><br><span class="hljs-comment line-number">7.</span>});<br></code></pre>

<p><strong>吃了亏，上了当。马上去阅读了下Laravel5.2的<code>发行版说明</code>。</strong>嗯，心安了。</p></div><div id="wmd-preview-section-11072" class="wmd-preview-section preview-content">

<h2 id="我是华丽的分割线">＝＝＝＝＝＝我是华丽的分割线＝＝＝＝＝＝＝＝</h2>

<p>在读<code>发行版说明</code>的时候，发现一个新的特性<code>访问频率限制</code>蛮有意思的。之前写过一篇文章<a href="http://luhu.in/article/51" target="_blank">HTTP接口防止非法调用解决方案</a>，说过自己对URL一次使用的设计。看到这个<code>访问频率限制</code>中间件，我十分心痒，想一探究竟。</p>

<p>在正式开始之前，先说下阅读源码的收获。最后我们可以核对下这些收获是不是正确的。</p>

<ol><li rel="1">访问频率限制是在缓存的基础上实现的</li>
<li rel="2">Laravel的缓存中一个key为一个缓存文件。</li>
<li rel="3">缓存目录组织结构:<code>Laravel/storage/framework/cache/ad/37、ad37de1f7785b51598726ad782b7d95ee38f669a</code>,其中从cache以下的路径都是通过<code>key</code>进行散列生成的。</li>
<li rel="4">缓存的文件内容:<code>1463467008i:2</code>,从0～9位为Unix时间戳,记录的是<code>key</code>的失效时间，从第10位开始是经过<code>serialize</code>序列化后的数据，也就是我们存储的值。</li>
</ol>

<p>好了，这里我们还是从<code>访问频率限制</code>中间件开始，由于Laravel默认是以<code>文件</code>作为缓存。所以我们阅读的也是这部分，这个看懂了。再看其他的缓存实现也就看懂了。</p>

<p>实现<code>访问频率限制</code>中间件的文件是<code>vendor/laravel/framework/src/Illuminate/Routing/Middleware/ThrottleRequests.php</code>，打开看一下，主要就是<code>handle</code>函数。</p></div><div id="wmd-preview-section-5333" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs xquery"><span class="hljs-comment line-number">1.</span><br><span class="hljs-comment line-number">2.</span>    public <span class="hljs-keyword">function</span> handle(<span class="hljs-variable">$request</span>, Closure <span class="hljs-variable">$next</span>, <span class="hljs-variable">$maxAttempts</span> = <span class="hljs-number">60</span>, <span class="hljs-variable">$decayMinutes</span> = <span class="hljs-number">1</span>)<br><span class="hljs-comment line-number">3.</span>    {<br><span class="hljs-comment line-number">4.</span>        //获取key，通过散列路由、请求的URL、IP地址等数据得到<br><span class="hljs-comment line-number">5.</span>        <span class="hljs-variable">$key</span> = <span class="hljs-variable">$this-</span>&gt;resolveRequestSignature(<span class="hljs-variable">$request</span>);<br><span class="hljs-comment line-number">6.</span>        //检查缓存，判断是否超出请求限制，超出返回Too Many Attempts. <span class="hljs-number">429</span><br><span class="hljs-comment line-number">7.</span>        if (<span class="hljs-variable">$this-</span>&gt;limiter-&gt;tooManyAttempts(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$maxAttempts</span>, <span class="hljs-variable">$decayMinutes</span>)) {<br><span class="hljs-comment line-number">8.</span>            return <span class="hljs-variable">$this-</span>&gt;buildResponse(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$maxAttempts</span>);<br><span class="hljs-comment line-number">9.</span>        }<br><span class="hljs-comment line-number">10.</span>        //正常访问，访问次数+<span class="hljs-number">1</span><br><span class="hljs-comment line-number">11.</span>        <span class="hljs-variable">$this-</span>&gt;limiter-&gt;hit(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$decayMinutes</span>);<br><span class="hljs-comment line-number">12.</span>        //正常流程<br><span class="hljs-comment line-number">13.</span>        <span class="hljs-variable">$response</span> = <span class="hljs-variable">$next</span>(<span class="hljs-variable">$request</span>);<br><span class="hljs-comment line-number">14.</span><br><span class="hljs-comment line-number">15.</span>        return <span class="hljs-variable">$this-</span>&gt;addHeaders(<br><span class="hljs-comment line-number">16.</span>            <span class="hljs-variable">$response</span>, <span class="hljs-variable">$maxAttempts</span>,<br><span class="hljs-comment line-number">17.</span>            <span class="hljs-variable">$this-</span>&gt;calculateRemainingAttempts(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$maxAttempts</span>)<br><span class="hljs-comment line-number">18.</span>        );<br></code></pre>

<p>这里看下<code>tooManyAttempts</code>函数，它在<code>vendor/laravel/framework/src/Illuminate/Cache/RateLimiter.php</code>文件里,里面还有</p></div><div id="wmd-preview-section-3278" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs xquery"><span class="hljs-comment line-number">1.</span>  public <span class="hljs-keyword">function</span> tooManyAttempts(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$maxAttempts</span>, <span class="hljs-variable">$decayMinutes</span> = <span class="hljs-number">1</span>)<br><span class="hljs-comment line-number">2.</span>    {<br><span class="hljs-comment line-number">3.</span>        //开始检查缓存了:对于这个key有没有锁定标记<br><span class="hljs-comment line-number">4.</span>        if (<span class="hljs-variable">$this-</span>&gt;cache-&gt;has(<span class="hljs-variable">$key</span>.<span class="hljs-string">':lockout'</span>)) {<br><span class="hljs-comment line-number">5.</span>            return true;<br><span class="hljs-comment line-number">6.</span>        }<br><span class="hljs-comment line-number">7.</span>        //读取访问次数，超出最大次数。则创建锁定标记。标记<br><span class="hljs-comment line-number">8.</span>        //失效时间为我们定义的时间。<br><span class="hljs-comment line-number">9.</span>        if (<span class="hljs-variable">$this-</span>&gt;attempts(<span class="hljs-variable">$key</span>) &gt; <span class="hljs-variable">$maxAttempts</span>) {<br><span class="hljs-comment line-number">10.</span>            <span class="hljs-variable">$this-</span>&gt;cache-&gt;add(<span class="hljs-variable">$key</span>.<span class="hljs-string">':lockout'</span>, time() + (<span class="hljs-variable">$decayMinutes</span> * <span class="hljs-number">60</span>), <span class="hljs-variable">$decayMinutes</span>);<br><span class="hljs-comment line-number">11.</span><br><span class="hljs-comment line-number">12.</span>            return true;<br><span class="hljs-comment line-number">13.</span>        }<br><span class="hljs-comment line-number">14.</span><br><span class="hljs-comment line-number">15.</span>        return false;<br><span class="hljs-comment line-number">16.</span>    }<br></code></pre>

<p>最后再来看下，key的生成:</p>

</div><div id="wmd-preview-section-11108" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs xquery"><span class="hljs-comment line-number">1.</span>  public <span class="hljs-keyword">function</span> fingerprint()<br><span class="hljs-comment line-number">2.</span>    {<br><span class="hljs-comment line-number">3.</span>        if (! <span class="hljs-variable">$this-</span>&gt;route()) {<br><span class="hljs-comment line-number">4.</span>            throw new RuntimeException(<span class="hljs-string">'Unable to generate fingerprint. Route unavailable.'</span>);<br><span class="hljs-comment line-number">5.</span>        }<br><span class="hljs-comment line-number">6.</span><br><span class="hljs-comment line-number">7.</span>        return sha1(<br><span class="hljs-comment line-number">8.</span>            implode(<span class="hljs-string">'|'</span>, <span class="hljs-variable">$this-</span>&gt;route()-&gt;methods()).<br><span class="hljs-comment line-number">9.</span>            <span class="hljs-string">'|'</span>.<span class="hljs-variable">$this-</span>&gt;route()-&gt;domain().<br><span class="hljs-comment line-number">10.</span>            <span class="hljs-string">'|'</span>.<span class="hljs-variable">$this-</span>&gt;route()-&gt;uri().//url<br><span class="hljs-comment line-number">11.</span>            <span class="hljs-string">'|'</span>.<span class="hljs-variable">$this-</span>&gt;ip()//IP地址<br><span class="hljs-comment line-number">12.</span>        );<br><span class="hljs-comment line-number">13.</span>    }<br></code></pre>

<p>可以看到<code>访问频率限制</code>中间件通过缓存实现、每个client端对特定url的请求会产生一个自己的<code>key</code>。当从缓存中读取<code>key</code>的时候，也许取不到。就返回<code>null</code>值。如果取得到则判断Unix时间戳，看看是否超过有效时间。超过则删除这个<code>key</code>,并返回<code>null</code>(这一步表示client过了一段时间，再次访问)。不超过有效时间则返回(一定时间内的连续访问)。这一段处理是在缓存里面做的。我们稍后在看。接下里就是<code>RateLimiter</code>的<code>tooManyAttempts</code>函数做处理了(具体看注释)。**分工真的很明确!!!! </p>

<p>好，我们继续往下看Laravel对缓存的实现。打开<code>vendor/laravel/framework/src/Illuminate/Cache/FileStore.php</code>文件，这是对文件缓存的实现,这里主要看三个函数:<code>getPayload</code>、<code>put</code>,<code>path</code>。其他函数也蛮有意思，也很简单。比如阅读<code>expiration</code>函数会知道设置有效时间为0(或者超大值)表示永不过期。言归正传，首先来看<code>getPayload</code>函数</p></div><div id="wmd-preview-section-11131" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs xquery"><span class="hljs-comment line-number">1.</span>protected <span class="hljs-keyword">function</span> getPayload(<span class="hljs-variable">$key</span>)<br><span class="hljs-comment line-number">2.</span>    {<br><span class="hljs-comment line-number">3.</span>        //根据key得到,得到文件路径。算法一会在看<br><span class="hljs-comment line-number">4.</span>        //还记得<span class="hljs-variable">$key</span>是怎么生成的了吗?<br><span class="hljs-comment line-number">5.</span>        <span class="hljs-variable">$path</span> = <span class="hljs-variable">$this-</span>&gt;path(<span class="hljs-variable">$key</span>);<br><span class="hljs-comment line-number">6.</span><br><span class="hljs-comment line-number">7.</span>        try {<br><span class="hljs-comment line-number">8.</span>        //读取文件内容，并获取过期时间戳<br><span class="hljs-comment line-number">9.</span>        //如果文件不存在，files的get函数会抛出异常，这个时候<br><span class="hljs-comment line-number">10.</span>        //则返回空值<br><span class="hljs-comment line-number">11.</span>            <span class="hljs-variable">$expire</span> = substr(<span class="hljs-variable">$contents</span> = <span class="hljs-variable">$this-</span>&gt;files-&gt;get(<span class="hljs-variable">$path</span>), <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br><span class="hljs-comment line-number">12.</span>        } catch (Exception <span class="hljs-variable">$e</span>) {<br><span class="hljs-comment line-number">13.</span>            return [<span class="hljs-string">'data'</span> =&gt; null, <span class="hljs-string">'time'</span> =&gt; null];<br><span class="hljs-comment line-number">14.</span>        }<br><span class="hljs-comment line-number">15.</span><br><span class="hljs-comment line-number">16.</span>         //判断缓存是否失效，失效则删除，并且返回空值<br><span class="hljs-comment line-number">17.</span>        if (time() &gt;= <span class="hljs-variable">$expire</span>) {<br><span class="hljs-comment line-number">18.</span>            <span class="hljs-variable">$this-</span>&gt;forget(<span class="hljs-variable">$key</span>);<br><span class="hljs-comment line-number">19.</span><br><span class="hljs-comment line-number">20.</span>            return [<span class="hljs-string">'data'</span> =&gt; null, <span class="hljs-string">'time'</span> =&gt; null];<br><span class="hljs-comment line-number">21.</span>        }<br><span class="hljs-comment line-number">22.</span>        //反序列化数据<br><span class="hljs-comment line-number">23.</span>        <span class="hljs-variable">$data</span> = unserialize(substr(<span class="hljs-variable">$contents</span>, <span class="hljs-number">10</span>));<br><span class="hljs-comment line-number">24.</span>        //计算有效剩余的时间<br><span class="hljs-comment line-number">25.</span>        <span class="hljs-variable">$time</span> = ceil((<span class="hljs-variable">$expire</span> - time()) / <span class="hljs-number">60</span>);<br><span class="hljs-comment line-number">26.</span>        //返回一个数组:data是数据，time是剩余的有效时间<br><span class="hljs-comment line-number">27.</span>        return compact(<span class="hljs-string">'data'</span>, <span class="hljs-string">'time'</span>);<br><span class="hljs-comment line-number">28.</span>    }<br></code></pre>

<p>是不是跟上面的叙述一模一样?读取的我们看完了，再来看写入的:</p></div><div id="wmd-preview-section-8624" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs xquery"><span class="hljs-comment line-number">1.</span> public <span class="hljs-keyword">function</span> put(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$value</span>, <span class="hljs-variable">$minutes</span>)<br><span class="hljs-comment line-number">2.</span>    {<br><span class="hljs-comment line-number">3.</span>    //拼接存储的内容:过期时间戳+值<br><span class="hljs-comment line-number">4.</span>        <span class="hljs-variable">$value</span> = <span class="hljs-variable">$this-</span>&gt;expiration(<span class="hljs-variable">$minutes</span>).serialize(<span class="hljs-variable">$value</span>);<br><span class="hljs-comment line-number">5.</span>        //创建存储目录<br><span class="hljs-comment line-number">6.</span>        <span class="hljs-variable">$this-</span>&gt;createCacheDirectory(<span class="hljs-variable">$path</span> = <span class="hljs-variable">$this-</span>&gt;path(<span class="hljs-variable">$key</span>));<br><span class="hljs-comment line-number">7.</span>        //file_put_contents<br><span class="hljs-comment line-number">8.</span>        <span class="hljs-variable">$this-</span>&gt;files-&gt;put(<span class="hljs-variable">$path</span>, <span class="hljs-variable">$value</span>);<br><span class="hljs-comment line-number">9.</span>    }<br></code></pre>

<p>很简单，最后再来看下缓存的目录结构是怎么生成的。</p>

</div><div id="wmd-preview-section-10814" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs xquery"><span class="hljs-comment line-number">1.</span>    protected <span class="hljs-keyword">function</span> path(<span class="hljs-variable">$key</span>)<br><span class="hljs-comment line-number">2.</span>    {<br><span class="hljs-comment line-number">3.</span>        //把<span class="hljs-variable">$key</span>散列，并分组。取出前四个字符。每个两个字符为一组。<br><span class="hljs-comment line-number">4.</span>        //产生[<span class="hljs-string">'ad'</span>,<span class="hljs-string">'37'</span>]<br><span class="hljs-comment line-number">5.</span>        <span class="hljs-variable">$parts</span> = array_slice(str_split(<span class="hljs-variable">$hash</span> = sha1(<span class="hljs-variable">$key</span>), <span class="hljs-number">2</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment line-number">6.</span>        //生成path，比如:storage/framework/cache/ad/<span class="hljs-number">37</span>/ad37de1f7785b51598726ad782b7d95ee38f669a<br><span class="hljs-comment line-number">7.</span>        return <span class="hljs-variable">$this-</span>&gt;directory.<span class="hljs-string">'/'</span>.implode(<span class="hljs-string">'/'</span>, <span class="hljs-variable">$parts</span>).<span class="hljs-string">'/'</span>.<span class="hljs-variable">$hash</span>;<br><span class="hljs-comment line-number">8.</span><br></code></pre>

<p>阅读源码结束了。在回过头看看开头写的那几点。是不是如此？在翻一翻<code>RedisStore.php</code>,<code>ArrayStore.php</code>，发现大同小异–都实现了<code>Store</code>接口。认真去读的话，都能读的懂了。好了，本文到此也结束了、希望对你有所帮助。 </p></div><div id="wmd-preview-section-10364" class="wmd-preview-section preview-content"></div><div id="wmd-preview-section-footnotes" class="preview-content"></div></div></body></html>